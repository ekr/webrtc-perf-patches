From e774263a4e07de5e3fa849d48bc5f0e7e346c9dc Mon Sep 17 00:00:00 2001
From: slee <slee@mozilla.com>
Date: Thu, 23 May 2013 09:50:18 +0800
Subject: [PATCH] add AudioDeviceGonk from bug 825112

---
 content/media/webrtc/AudioDeviceGonk.cpp | 2321 ++++++++++++++++++++++++++++++
 content/media/webrtc/AudioDeviceGonk.h   |  317 ++++
 2 files changed, 2638 insertions(+)
 create mode 100644 content/media/webrtc/AudioDeviceGonk.cpp
 create mode 100644 content/media/webrtc/AudioDeviceGonk.h

diff --git a/content/media/webrtc/AudioDeviceGonk.cpp b/content/media/webrtc/AudioDeviceGonk.cpp
new file mode 100644
index 0000000..55cfd4f
--- /dev/null
+++ b/content/media/webrtc/AudioDeviceGonk.cpp
@@ -0,0 +1,2321 @@
+/*
+ *  Copyright (c) 2012 The WebRTC project authors. All Rights Reserved.
+ *
+ *  Use of this source code is governed by a BSD-style license
+ *  that can be found in the LICENSE file in the root of the source
+ *  tree. An additional intellectual property rights grant can be found
+ *  in the file PATENTS.  All contributing project authors may
+ *  be found in the AUTHORS file in the root of the source tree.
+ */
+
+#include "AudioDeviceGonk.h"
+#include "audio_device_config.h"
+#include "common_audio/signal_processing/include/signal_processing_library.h"
+#include "system_wrappers/interface/ref_count.h"
+#include "system_wrappers/interface/event_wrapper.h"
+#include "mtransport/runnable_utils.h"
+
+#include "nsThreadUtils.h"
+
+#include <assert.h>
+#include <string.h>
+
+#include "trace.h"
+
+#define CHECK_INITIALIZED()         \
+{                                   \
+  if (!mInitialized) {              \
+    return -1;                      \
+  };                                \
+}
+
+#define CHECK_INITIALIZED_BOOL()    \
+{                                   \
+  if (!mInitialized) {              \
+    return false;                   \
+  };                                \
+}
+
+using namespace mozilla;
+using namespace android;
+
+namespace webrtc
+{
+
+// ============================================================================
+//                                   Static methods
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+//  AudioDeviceModule::Create()
+// ----------------------------------------------------------------------------
+
+AudioDeviceModule* AudioDeviceGonk::Create(const WebRtc_Word32 id,
+                                                 const AudioLayer audioLayer)
+{
+  // Create the generic ref counted (platform independent) implementation.
+  RefCountImpl<AudioDeviceGonk>* audioDevice =
+    new RefCountImpl<AudioDeviceGonk>(id, audioLayer);
+
+  // Ensure that the generic audio buffer can communicate with the
+  // platform-specific parts.
+  if (audioDevice->AttachAudioBuffer() == -1)
+  {
+    delete audioDevice;
+    return NULL;
+  }
+
+  WebRtcSpl_Init();
+
+  return audioDevice;
+}
+
+// ============================================================================
+//                            Construction & Destruction
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+//  AudioDeviceGonk - ctor
+// ----------------------------------------------------------------------------
+
+AudioDeviceGonk::AudioDeviceGonk(const WebRtc_Word32 id, const AudioLayer audioLayer)
+  : mCritSect("ModuleLock")
+  , mCritSectEventCb("EventCallbackLock")
+  , mCritSectAudioCb("AudioCallbackLock")
+  , mPtrCbAudioDeviceObserver(NULL)
+  , mId(id)
+  , mLastProcessTime(PR_Now() / 1000)
+  , mInitialized(false)
+  , mLastError(kAdmErrNone)
+  , mTimeEventRec(*EventWrapper::Create())
+  , mTimeEventPlay(*EventWrapper::Create())
+  , mRecStartStopEvent(*EventWrapper::Create())
+  , mPlayStartStopEvent(*EventWrapper::Create())
+  , mThreadPlay(NULL)
+  , mThreadRec(NULL)
+  , mPlayThreadIsInitialized(false)
+  , mRecThreadIsInitialized(false)
+  , mShutdownPlayThread(false)
+  , mShutdownRecThread(false)
+  , mRecordingDeviceIsSpecified(false)
+  , mPlayoutDeviceIsSpecified(false)
+  , mRecording(false)
+  , mPlaying(false)
+  , mRecIsInitialized(false)
+  , mPlayIsInitialized(false)
+  , mMicIsInitialized(false)
+  , mSpeakerIsInitialized(false)
+  , mStartRec(false)
+  , mStopRec(false)
+  , mStartPlay(false)
+  , mStopPlay(false)
+  , mPlayWarning(0)
+  , mPlayError(0)
+  , mRecWarning(0)
+  , mRecError(0)
+  , mDelayPlayout(0)
+  , mDelayRecording(0)
+  , mAGC(false)
+  , mSamplingFreqIn(N_REC_SAMPLES_PER_SEC/1000)
+  , mSamplingFreqOut(N_PLAY_SAMPLES_PER_SEC/1000)
+  , mMaxSpeakerVolume(0)
+  , mLoudSpeakerOn(false)
+  , mRecAudioSource(1) // 1 is AudioSource.MIC which is our default
+  , mBufferedPlaySamples(0)
+  , mBufferedRecSamples(0)
+  , mPlayPosition(0)
+  , mAudioTrack(NULL)
+  , mAudioRecord(NULL)
+  , mAudioFlinger(NULL)
+{
+  WEBRTC_TRACE(kTraceMemory, kTraceAudioDevice, id, "%s created", __FUNCTION__);
+}
+
+// ----------------------------------------------------------------------------
+//  AttachAudioBuffer
+//
+//  Install "bridge" between the platform implemetation and the generic
+//  implementation. The "child" shall set the native sampling rate and the
+//  number of channels in this function call.
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::AttachAudioBuffer()
+{
+  ReentrantMonitorAutoEnter lock(mCritSect);
+  WEBRTC_TRACE(kTraceInfo, kTraceAudioDevice, mId, "%s", __FUNCTION__);
+
+  mAudioDeviceBuffer.SetId(mId);
+
+  // inform the AudioBuffer about default settings for this implementation
+  mAudioDeviceBuffer.SetRecordingSampleRate(N_REC_SAMPLES_PER_SEC);
+  mAudioDeviceBuffer.SetPlayoutSampleRate(N_PLAY_SAMPLES_PER_SEC);
+  mAudioDeviceBuffer.SetRecordingChannels(N_REC_CHANNELS);
+  mAudioDeviceBuffer.SetPlayoutChannels(N_PLAY_CHANNELS);
+
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  ~AudioDeviceGonk - dtor
+// ----------------------------------------------------------------------------
+
+AudioDeviceGonk::~AudioDeviceGonk()
+{
+  WEBRTC_TRACE(kTraceMemory, kTraceAudioDevice, mId, "%s destroyed", __FUNCTION__);
+  Terminate();
+}
+
+// ============================================================================
+//                                  Module
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+//  Module::ChangeUniqueId
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::ChangeUniqueId(const WebRtc_Word32 id)
+{
+  mId = id;
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  Module::TimeUntilNextProcess
+//
+//  Returns the number of milliseconds until the module want a worker thread
+//  to call Process().
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::TimeUntilNextProcess()
+{
+  WebRtc_UWord32 now = PR_Now() / 1000;
+  WebRtc_Word32 deltaProcess = kAdmMaxIdleTimeProcess - (now - mLastProcessTime);
+  return (deltaProcess);
+}
+
+// ----------------------------------------------------------------------------
+//  Module::Process
+//
+//  Check for posted error and warning reports. Generate callbacks if
+//  new reports exists.
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::Process()
+{
+  ReentrantMonitorAutoEnter lock(mCritSect);
+  mLastProcessTime = PR_Now() / 1000;
+
+  // kPlayoutWarning
+  if (mPlayWarning > 0)
+  {
+    ReentrantMonitorAutoEnter lock(mCritSectEventCb);
+    if (mPtrCbAudioDeviceObserver)
+    {
+      WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId, "=> OnWarningIsReported(kPlayoutWarning)");
+      mPtrCbAudioDeviceObserver->OnWarningIsReported(AudioDeviceObserver::kPlayoutWarning);
+    }
+    mPlayWarning = 0;
+  }
+
+  // kPlayoutError
+  if (mPlayError > 0)
+  {
+    ReentrantMonitorAutoEnter lock(mCritSectEventCb);
+    if (mPtrCbAudioDeviceObserver)
+    {
+      WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId, "=> OnErrorIsReported(kPlayoutError)");
+      mPtrCbAudioDeviceObserver->OnErrorIsReported(AudioDeviceObserver::kPlayoutError);
+    }
+    mPlayError = 0;
+  }
+
+  // kRecordingWarning
+  if (mRecWarning > 0)
+  {
+    ReentrantMonitorAutoEnter lock(mCritSectEventCb);
+    if (mPtrCbAudioDeviceObserver)
+    {
+      WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId, "=> OnWarningIsReported(kRecordingWarning)");
+      mPtrCbAudioDeviceObserver->OnWarningIsReported(AudioDeviceObserver::kRecordingWarning);
+    }
+    mRecWarning = 0;
+  }
+
+  // kRecordingError
+  if (mRecError > 0)
+  {
+    ReentrantMonitorAutoEnter lock(mCritSectEventCb);
+    if (mPtrCbAudioDeviceObserver)
+    {
+      WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId, "=> OnErrorIsReported(kRecordingError)");
+      mPtrCbAudioDeviceObserver->OnErrorIsReported(AudioDeviceObserver::kRecordingError);
+    }
+    mRecError = 0;
+  }
+
+  return 0;
+}
+
+// ============================================================================
+//                                    Public API
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+//  ActiveAudioLayer
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::ActiveAudioLayer(AudioLayer* audioLayer) const
+{
+  *audioLayer = kPlatformDefaultAudio;
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  LastError
+// ----------------------------------------------------------------------------
+
+AudioDeviceModule::ErrorCode AudioDeviceGonk::LastError() const
+{
+  return mLastError;
+}
+
+// ----------------------------------------------------------------------------
+//  Init
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::Init()
+{
+  ReentrantMonitorAutoEnter lock(mCritSect);
+  if (mInitialized)
+      return 0;
+
+  mPlayWarning = 0;
+  mPlayError = 0;
+  mRecWarning = 0;
+  mRecError = 0;
+  mAudioFlinger = AudioSystem::get_audio_flinger();
+
+  // Check the sample rate to be used for playback and recording
+  // and the max playout volume
+  if (InitSampleRate() != 0)
+  {
+    WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                 "%s: Failed to init samplerate", __FUNCTION__);
+    return -1;
+  }
+
+  // RECORDING
+  //const char* threadName = "AudioCapture";
+  NS_NewThread(getter_AddRefs(mThreadRec));
+  if (mThreadRec == nullptr)
+  {
+    WEBRTC_TRACE(kTraceCritical, kTraceAudioDevice, mId,
+                 "  failed to create the rec audio thread");
+    return -1;
+  }
+  mThreadRec->Dispatch(WrapRunnable(this, &AudioDeviceGonk::RecThreadFunc), NS_DISPATCH_NORMAL);
+
+  // PLAYOUT
+  //threadName = "AudioRender";
+  NS_NewThread(getter_AddRefs(mThreadPlay));
+  if (mThreadPlay == nullptr)
+  {
+    WEBRTC_TRACE(kTraceCritical, kTraceAudioDevice, mId,
+                 "  failed to create the play audio thread");
+    return -1;
+  }
+  mThreadPlay->Dispatch(WrapRunnable(this, &AudioDeviceGonk::PlayThreadFunc), NS_DISPATCH_NORMAL);
+
+  mInitialized = true;
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  Terminate
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::Terminate()
+{
+  ReentrantMonitorAutoEnter lock(mCritSect);
+
+  if (mInitialized)
+    return 0;
+
+  // RECORDING
+  StopRecording();
+  mShutdownRecThread = true;
+  mTimeEventRec.Set(); // Release rec thread from waiting state
+  if (mThreadRec != nullptr)
+  {
+    UnLock();
+    if (kEventSignaled != mRecStartStopEvent.Wait(5000))
+    {
+      WEBRTC_TRACE(kTraceError,
+                   kTraceAudioDevice,
+                   mId,
+                   "%s: Recording thread shutdown timed out, cannot "
+                   "terminate thread",
+                   __FUNCTION__);
+      // If we close thread anyway, the app will crash
+      Lock();
+      return -1;
+    }
+    mRecStartStopEvent.Reset();
+
+    // Close down rec thread
+    mThreadRec->Shutdown();
+    Lock();
+    mThreadRec = nullptr;
+    // Release again, we might have returned to waiting state
+    mTimeEventRec.Set();
+    mRecThreadIsInitialized = false;
+  }
+  mMicIsInitialized = false;
+  mRecordingDeviceIsSpecified = false;
+
+  // PLAYOUT
+  StopPlayout();
+  mShutdownPlayThread = true;
+  mTimeEventPlay.Set(); // Release rec thread from waiting state
+  if (mThreadPlay != nullptr)
+  {
+    UnLock();
+    if (kEventSignaled != mPlayStartStopEvent.Wait(5000))
+    {
+      WEBRTC_TRACE(kTraceError,
+                   kTraceAudioDevice,
+                   mId,
+                   "%s: Playout thread shutdown timed out, cannot "
+                   "terminate thread",
+                   __FUNCTION__);
+      // If we close thread anyway, the app will crash
+      Lock();
+      return -1;
+    }
+    mPlayStartStopEvent.Reset();
+
+    // Close down play thread
+    mThreadPlay->Shutdown();
+    Lock();
+    mThreadPlay = nullptr;
+    mTimeEventPlay.Set();
+    mPlayThreadIsInitialized = false;
+  }
+
+  mSpeakerIsInitialized = false;
+  mPlayoutDeviceIsSpecified = false;
+  mInitialized = false;
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  Initialized
+// ----------------------------------------------------------------------------
+
+bool AudioDeviceGonk::Initialized() const
+{
+  WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId, "output: %d", mInitialized);
+  return mInitialized;
+}
+
+// ----------------------------------------------------------------------------
+//  SpeakerIsAvailable
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::SpeakerIsAvailable(bool* available)
+{
+  CHECK_INITIALIZED();
+
+  // We always assume it's available
+  *available = true;
+
+  WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId, "output: available=%d", *available);
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  InitSpeaker
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::InitSpeaker()
+{
+  CHECK_INITIALIZED();
+  ReentrantMonitorAutoEnter lock(mCritSect);
+
+  if (mPlaying)
+  {
+    WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+                 "  Playout already started");
+    return -1;
+  }
+
+  if (!mPlayoutDeviceIsSpecified)
+  {
+      WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                   "  Playout device is not specified");
+      return -1;
+  }
+
+  // Nothing needs to be done here, we use a flag to have consistent
+  // behavior with other platforms
+  mSpeakerIsInitialized = true;
+
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  MicrophoneIsAvailable
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::MicrophoneIsAvailable(bool* available)
+{
+  CHECK_INITIALIZED();
+
+  // We always assume it's available
+  *available = true;
+
+  WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId, "output: available=%d", *available);
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  InitMicrophone
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::InitMicrophone()
+{
+  CHECK_INITIALIZED();
+  ReentrantMonitorAutoEnter lock(mCritSect);
+
+  if (mRecording)
+  {
+    WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+                 "  Recording already started");
+    return -1;
+  }
+
+  if (!mRecordingDeviceIsSpecified)
+  {
+    WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                 "  Recording device is not specified");
+    return -1;
+  }
+
+  // Nothing needs to be done here, we use a flag to have consistent
+  // behavior with other platforms
+  mMicIsInitialized = true;
+
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  SpeakerVolumeIsAvailable
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::SpeakerVolumeIsAvailable(bool* available)
+{
+  CHECK_INITIALIZED();
+
+  // We assume we are always be able to set/get volume
+  *available = true;
+
+  WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId, "output: available=%d", *available);
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  SetSpeakerVolume
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::SetSpeakerVolume(WebRtc_UWord32 volume)
+{
+  CHECK_INITIALIZED();
+
+  if (!mInitialized)
+  {
+    WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                 "  Audio device not initialized");
+    return -1;
+  }
+
+  if (!mSpeakerIsInitialized)
+  {
+    WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                 "  Speaker not initialized");
+    return -1;
+  }
+
+  mAudioFlinger->setStreamVolume(AUDIO_STREAM_MUSIC,
+                                 static_cast<float>(volume), 0);
+
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  SpeakerVolume
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::SpeakerVolume(WebRtc_UWord32* volume) const
+{
+  CHECK_INITIALIZED();
+
+  if (!mInitialized)
+  {
+    WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                 "  Audio device not initialized");
+    return -1;
+  }
+
+  if (!mSpeakerIsInitialized)
+  {
+    WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                 "  Speaker not initialized");
+    return -1;
+  }
+
+  *volume = mAudioFlinger->streamVolume(AUDIO_STREAM_MUSIC, 0);
+
+  WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId, "output: volume=%u", *volume);
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  SetWaveOutVolume
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::SetWaveOutVolume(WebRtc_UWord16 volumeLeft, WebRtc_UWord16 volumeRight)
+{
+  CHECK_INITIALIZED();
+  WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+               "  API call not supported on this platform: %s", __FUNCTION__);
+  return -1;
+}
+
+// ----------------------------------------------------------------------------
+//  WaveOutVolume
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::WaveOutVolume(WebRtc_UWord16* volumeLeft, WebRtc_UWord16* volumeRight) const
+{
+  CHECK_INITIALIZED();
+  WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+               "  API call not supported on this platform: %s", __FUNCTION__);
+  return -1;
+}
+
+// ----------------------------------------------------------------------------
+//  SpeakerIsInitialized
+// ----------------------------------------------------------------------------
+
+bool AudioDeviceGonk::SpeakerIsInitialized() const
+{
+  CHECK_INITIALIZED_BOOL();
+  WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId, "output: %d", mSpeakerIsInitialized);
+  return mSpeakerIsInitialized;
+}
+
+// ----------------------------------------------------------------------------
+//  MicrophoneIsInitialized
+// ----------------------------------------------------------------------------
+
+bool AudioDeviceGonk::MicrophoneIsInitialized() const
+{
+  CHECK_INITIALIZED_BOOL();
+  WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId, "output: %d", mMicIsInitialized);
+  return mMicIsInitialized;
+}
+
+// ----------------------------------------------------------------------------
+//  MaxSpeakerVolume
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::MaxSpeakerVolume(WebRtc_UWord32* maxVolume) const
+{
+  CHECK_INITIALIZED();
+
+  if (!mSpeakerIsInitialized)
+  {
+      WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                   "  Speaker not initialized");
+      return -1;
+  }
+
+  *maxVolume = mMaxSpeakerVolume;
+
+  WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId, "output: maxVolume=%d", *maxVolume);
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  MinSpeakerVolume
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::MinSpeakerVolume(WebRtc_UWord32* minVolume) const
+{
+  CHECK_INITIALIZED();
+
+  if (!mSpeakerIsInitialized)
+  {
+    WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                 "  Speaker not initialized");
+    return -1;
+  }
+
+  *minVolume = 0;
+
+  WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId, "output: minVolume=%u", *minVolume);
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  SpeakerVolumeStepSize
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::SpeakerVolumeStepSize(WebRtc_UWord16* stepSize) const
+{
+  CHECK_INITIALIZED();
+
+  if (!mSpeakerIsInitialized)
+  {
+      WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                   "  Speaker not initialized");
+      return -1;
+  }
+
+  *stepSize = 1;
+
+  WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId, "output: stepSize=%u", *stepSize);
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  SpeakerMuteIsAvailable
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::SpeakerMuteIsAvailable(bool* available)
+{
+  CHECK_INITIALIZED();
+
+  // Speaker mute not supported on Gonk
+  *available = false;
+
+  WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId, "output: available=%d", *available);
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  SetSpeakerMute
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::SetSpeakerMute(bool enable)
+{
+  CHECK_INITIALIZED();
+  WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+               "  API call not supported on this platform: %s", __FUNCTION__);
+  return -1;
+}
+
+// ----------------------------------------------------------------------------
+//  SpeakerMute
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::SpeakerMute(bool* enabled) const
+{
+  CHECK_INITIALIZED();
+  WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+               "  API call not supported on this platform: %s", __FUNCTION__);
+  return -1;
+}
+
+// ----------------------------------------------------------------------------
+//  MicrophoneMuteIsAvailable
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::MicrophoneMuteIsAvailable(bool* available)
+{
+  CHECK_INITIALIZED();
+
+  // Mic mute not supported on Gonk
+  *available = false;
+
+  WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId, "output: available=%d", *available);
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  SetMicrophoneMute
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::SetMicrophoneMute(bool enable)
+{
+  CHECK_INITIALIZED();
+  WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+               "  API call not supported on this platform: %s", __FUNCTION__);
+  return -1;
+}
+
+// ----------------------------------------------------------------------------
+//  MicrophoneMute
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::MicrophoneMute(bool* enabled) const
+{
+  CHECK_INITIALIZED();
+
+  WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+               "  API call not supported on this platform: %s", __FUNCTION__);
+  return -1;
+}
+
+// ----------------------------------------------------------------------------
+//  MicrophoneBoostIsAvailable
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::MicrophoneBoostIsAvailable(bool* available)
+{
+  CHECK_INITIALIZED();
+
+  // Mic boost not supported on Gonk
+  *available = false;
+
+  WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId, "output: available=%d", *available);
+  return (0);
+}
+
+// ----------------------------------------------------------------------------
+//  SetMicrophoneBoost
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::SetMicrophoneBoost(bool enable)
+{
+  CHECK_INITIALIZED();
+  WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+               "  API call not supported on this platform: %s", __FUNCTION__);
+  return -1;
+}
+
+// ----------------------------------------------------------------------------
+//  MicrophoneBoost
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::MicrophoneBoost(bool* enabled) const
+{
+  CHECK_INITIALIZED();
+  WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+               "  API call not supported on this platform: %s", __FUNCTION__);
+  return -1;
+}
+
+// ----------------------------------------------------------------------------
+//  MicrophoneVolumeIsAvailable
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::MicrophoneVolumeIsAvailable(bool* available)
+{
+  CHECK_INITIALIZED();
+
+  // Mic volume not supported on Gonk
+  *available = false;
+
+  WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId, "output: available=%d", *available);
+  return (0);
+}
+
+// ----------------------------------------------------------------------------
+//  SetMicrophoneVolume
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::SetMicrophoneVolume(WebRtc_UWord32 volume)
+{
+  CHECK_INITIALIZED();
+  WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+               "  API call not supported on this platform: %s", __FUNCTION__);
+  return -1;
+}
+
+// ----------------------------------------------------------------------------
+//  MicrophoneVolume
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::MicrophoneVolume(WebRtc_UWord32* volume) const
+{
+  CHECK_INITIALIZED();
+  WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+               "  API call not supported on this platform: %s", __FUNCTION__);
+  return -1;
+}
+
+// ----------------------------------------------------------------------------
+//  StereoRecordingIsAvailable
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::StereoRecordingIsAvailable(bool* available) const
+{
+  CHECK_INITIALIZED();
+
+  // Stereo recording not supported on Gonk
+  *available = false;
+
+  WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId, "output: available=%d", *available);
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  SetStereoRecording
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::SetStereoRecording(bool enable)
+{
+  CHECK_INITIALIZED();
+  WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+               "  API call not supported on this platform: %s", __FUNCTION__);
+  return -1;
+}
+
+// ----------------------------------------------------------------------------
+//  StereoRecording
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::StereoRecording(bool* enabled) const
+{
+  CHECK_INITIALIZED();
+  WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+               "  API call not supported on this platform: %s", __FUNCTION__);
+  return -1;
+}
+
+// ----------------------------------------------------------------------------
+//  SetRecordingChannel
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::SetRecordingChannel(const ChannelType channel)
+{
+  CHECK_INITIALIZED();
+  WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+               "  API call not supported on this platform: %s", __FUNCTION__);
+  return -1;
+}
+
+// ----------------------------------------------------------------------------
+//  RecordingChannel
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::RecordingChannel(ChannelType* channel) const
+{
+  CHECK_INITIALIZED();
+  WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+               "  API call not supported on this platform: %s", __FUNCTION__);
+  return -1;
+}
+
+// ----------------------------------------------------------------------------
+//  StereoPlayoutIsAvailable
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::StereoPlayoutIsAvailable(bool* available) const
+{
+  CHECK_INITIALIZED();
+
+  // Stereo playout not supported on Gonk
+  *available = false;
+
+  WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId, "output: available=%d", *available);
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  SetStereoPlayout
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::SetStereoPlayout(bool enable)
+{
+  CHECK_INITIALIZED();
+  WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+               "  API call not supported on this platform: %s", __FUNCTION__);
+  return -1;
+}
+
+// ----------------------------------------------------------------------------
+//  StereoPlayout
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::StereoPlayout(bool* enabled) const
+{
+  CHECK_INITIALIZED();
+  WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+               "  API call not supported on this platform: %s", __FUNCTION__);
+  return -1;
+}
+
+// ----------------------------------------------------------------------------
+//  SetAGC
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::SetAGC(bool enable)
+{
+  CHECK_INITIALIZED();
+  mAGC = enable;
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  AGC
+// ----------------------------------------------------------------------------
+
+bool AudioDeviceGonk::AGC() const
+{
+  CHECK_INITIALIZED_BOOL();
+  return mAGC;
+}
+
+// ----------------------------------------------------------------------------
+//  PlayoutIsAvailable
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::PlayoutIsAvailable(bool* available)
+{
+  CHECK_INITIALIZED();
+
+  *available = false;
+
+  // Try to initialize the playout side
+  WebRtc_Word32 res = InitPlayout();
+
+  // Cancel effect of initialization
+  StopPlayout();
+  if (res != -1)
+  {
+    *available = true;
+  }
+
+  WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId, "output: available=%d", *available);
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  RecordingIsAvailable
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::RecordingIsAvailable(bool* available)
+{
+  CHECK_INITIALIZED();
+
+  *available = false;
+
+  // Try to initialize the playout side
+  WebRtc_Word32 res = InitRecording();
+
+  // Cancel effect of initialization
+  StopRecording();
+
+  if (res != -1)
+  {
+    *available = true;
+  }
+
+  WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId, "output: available=%d", *available);
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  MaxMicrophoneVolume
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::MaxMicrophoneVolume(WebRtc_UWord32* maxVolume) const
+{
+  CHECK_INITIALIZED();
+  WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+               "  API call not supported on this platform: %s", __FUNCTION__);
+  return -1;
+}
+
+// ----------------------------------------------------------------------------
+//  MinMicrophoneVolume
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::MinMicrophoneVolume(WebRtc_UWord32* minVolume) const
+{
+  CHECK_INITIALIZED();
+  WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+               "  API call not supported on this platform: %s", __FUNCTION__);
+  return -1;
+}
+
+// ----------------------------------------------------------------------------
+//  MicrophoneVolumeStepSize
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::MicrophoneVolumeStepSize(WebRtc_UWord16* stepSize) const
+{
+  CHECK_INITIALIZED();
+  WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+               "  API call not supported on this platform: %s", __FUNCTION__);
+  return -1;
+}
+
+// ----------------------------------------------------------------------------
+//  PlayoutDevices
+// ----------------------------------------------------------------------------
+
+WebRtc_Word16 AudioDeviceGonk::PlayoutDevices()
+{
+  CHECK_INITIALIZED();
+  WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId, "output: #playout devices=%d", 1);
+  // There is one device only
+  return 1;
+}
+
+// ----------------------------------------------------------------------------
+//  SetPlayoutDevice I (II)
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::SetPlayoutDevice(WebRtc_UWord16 index)
+{
+  CHECK_INITIALIZED();
+  // All member used in this function is thread-safe, do not protect them here
+  if (mPlayIsInitialized)
+  {
+    WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                 "  Playout already initialized");
+    return -1;
+  }
+
+  if (0 != index)
+  {
+    WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                 "  Device index is out of range [0,0]");
+    return -1;
+  }
+
+  // Do nothing but set a flag, this is to have consistent behavior
+  // with other platforms
+  mPlayoutDeviceIsSpecified = true;
+
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  SetPlayoutDevice II (II)
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::SetPlayoutDevice(WindowsDeviceType device)
+{
+  WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+               "  API call not supported on this platform: %s", __FUNCTION__);
+  return -1;
+}
+
+// ----------------------------------------------------------------------------
+//  PlayoutDeviceName
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::PlayoutDeviceName(
+  WebRtc_UWord16 index,
+  char name[kAdmMaxDeviceNameSize],
+  char guid[kAdmMaxGuidSize])
+{
+  CHECK_INITIALIZED();
+
+  if (name == NULL)
+  {
+    mLastError = kAdmErrArgument;
+    return -1;
+  }
+
+  if (0 != index)
+  {
+    WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                 "  Device index is out of range [0,0]");
+    return -1;
+  }
+
+  // Return empty string
+  memset(name, 0, kAdmMaxDeviceNameSize);
+  WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId, "output: name=%s", name);
+
+  if (guid)
+  {
+    memset(guid, 0, kAdmMaxGuidSize);
+    WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId, "output: guid=%s", guid);
+  }
+
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  RecordingDeviceName
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::RecordingDeviceName(
+  WebRtc_UWord16 index,
+  char name[kAdmMaxDeviceNameSize],
+  char guid[kAdmMaxGuidSize])
+{
+  CHECK_INITIALIZED();
+
+  if (name == NULL)
+  {
+    mLastError = kAdmErrArgument;
+    return -1;
+  }
+
+  if (0 != index)
+  {
+    WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                 "  Device index is out of range [0,0]");
+    return -1;
+  }
+
+  // Return empty string
+  memset(name, 0, kAdmMaxDeviceNameSize);
+  WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId, "output: name=%s", name);
+  if (guid)
+  {
+    memset(guid, 0, kAdmMaxGuidSize);
+    WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId, "output: guid=%s", guid);
+  }
+
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  RecordingDevices
+// ----------------------------------------------------------------------------
+
+WebRtc_Word16 AudioDeviceGonk::RecordingDevices()
+{
+  CHECK_INITIALIZED();
+  WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId,
+               "output: #recording devices=%d", 1);
+  // There is one device only
+  return 1;
+}
+
+// ----------------------------------------------------------------------------
+//  SetRecordingDevice I (II)
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::SetRecordingDevice(WebRtc_UWord16 index)
+{
+  CHECK_INITIALIZED();
+  if (mRecIsInitialized)
+  {
+    WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                 "  Recording already initialized");
+    return -1;
+  }
+
+  // Recording device index will be used for specifying recording
+  // audio source, allow any value
+  mRecAudioSource = index;
+  mRecordingDeviceIsSpecified = true;
+
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  SetRecordingDevice II (II)
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::SetRecordingDevice(WindowsDeviceType device)
+{
+  CHECK_INITIALIZED();
+  WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+               "  API call not supported on this platform: %s", __FUNCTION__);
+  return -1;
+}
+
+// ----------------------------------------------------------------------------
+//  InitPlayout
+// ----------------------------------------------------------------------------
+
+// This is a utility function, which must be called with lock locked
+int AudioDeviceGonk::InitPlaybackLocked(int sampleRate)
+{
+  mBufferedPlaySamples = 0;
+
+  // release the object
+  if (mAudioTrack != NULL) {
+    mAudioTrack->stop();
+    delete mAudioTrack;
+    mAudioTrack = NULL;
+  }
+
+  int frameCount;
+  int channelMask = N_PLAY_CHANNELS == 1 ?
+                    AUDIO_CHANNEL_OUT_MONO : AUDIO_CHANNEL_OUT_STEREO;
+
+  AudioSystem::getOutputFrameCount(&frameCount);
+  mAudioTrack = new AudioTrack();
+  mAudioTrack->set(AUDIO_STREAM_MUSIC,  // streamType
+                   sampleRate,          // sampleRate
+                   N_AUDIO_FORMAT,      // format
+                   channelMask,         // channelMask
+                   frameCount,          // frameCount
+                   0,                   // flags
+                   NULL,                // callback
+                   this,                // user
+                   0,                   // notificationFrames
+                   0,                   // sharedBuffer
+                   false,               // threadCanCallJava
+                   0);                  // sessionId
+
+  // check that the audioTrack is ready to be used
+  if (mAudioTrack->initCheck() != NO_ERROR) {
+    return -1;
+  }
+
+  // XXX: Since there is no mechanism to determine MAX_VOLUME on Gonk now,
+  //      default to (MAX_STREAM_VOLUME[STREAM_MUSIC] + 5) / 10, where
+  //      MAX_STREAM_VOLUME[STREAM_MUSIC] = 15, from AudioService.java
+  return 2;
+}
+
+WebRtc_Word32 AudioDeviceGonk::InitPlayout()
+{
+  CHECK_INITIALIZED();
+  ReentrantMonitorAutoEnter lock(mCritSect);
+  mAudioDeviceBuffer.InitPlayout();
+
+  if (!mInitialized)
+  {
+    WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                 "  Not initialized");
+    return -1;
+  }
+
+  if (mPlaying)
+  {
+    WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+                 "  Playout already started");
+    return -1;
+  }
+
+  if (!mPlayoutDeviceIsSpecified)
+  {
+    WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                 "  Playout device is not specified");
+    return -1;
+  }
+
+  if (mPlayIsInitialized)
+  {
+    WEBRTC_TRACE(kTraceInfo, kTraceAudioDevice, mId,
+                 "  Playout already initialized");
+    return 0;
+  }
+
+  // Initialize the speaker
+  if (InitSpeaker() == -1)
+  {
+    WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+                 "  InitSpeaker() failed");
+  }
+
+  int samplingFreq = 44100;
+  if (mSamplingFreqOut != 44)
+  {
+    samplingFreq = mSamplingFreqOut * 1000;
+  }
+
+  int retVal = -1;
+
+  int res = InitPlaybackLocked(samplingFreq);
+  if (res < 0)
+  {
+    WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                 "InitPlaybackLocked failed (%d)", res);
+  }
+  else
+  {
+    // Set the audio device buffer sampling rate
+    mAudioDeviceBuffer.SetPlayoutSampleRate(mSamplingFreqOut * 1000);
+    mPlayIsInitialized = true;
+    retVal = 0;
+  }
+
+  return retVal;
+}
+
+
+static int GetPCMSampleSize(int audioFormat)
+{
+  switch (audioFormat)
+  {
+    case AUDIO_FORMAT_PCM_16_BIT:
+      return sizeof(int16_t);
+    case AUDIO_FORMAT_PCM_8_BIT:
+      return sizeof(int8_t);
+    case AUDIO_FORMAT_PCM_32_BIT:
+    case AUDIO_FORMAT_PCM_8_24_BIT:
+      return sizeof(int32_t);
+    default:
+      return -1;
+  }
+}
+
+static int GetMinRecordBufferSize(int sampleRate, int nbChannels, int audioFormat)
+{
+  int frameCount = 0;
+  status_t result = AudioRecord::getMinFrameCount(&frameCount,
+                                                  sampleRate,
+                                                  audioFormat,
+                                                  nbChannels);
+
+  if (result == BAD_VALUE) {
+    return 0;
+  }
+  if (result != NO_ERROR) {
+    return -1;
+  }
+  return frameCount * nbChannels * GetPCMSampleSize(audioFormat);
+}
+
+// ----------------------------------------------------------------------------
+//  InitRecording
+// ----------------------------------------------------------------------------
+int AudioDeviceGonk::InitRecorderLocked(int audioSource, int sampleRate)
+{
+  // get the minimum buffer size that can be used
+  int minRecBufSize = GetMinRecordBufferSize(sampleRate,
+                                             N_REC_CHANNELS,
+                                             N_AUDIO_FORMAT);
+
+  // create a bigger buffer to store PCM data, to avoid data loss if
+  // polling thread runs to slow
+  int recBufSize = minRecBufSize * 2;
+  mBufferedRecSamples = (5 * sampleRate) / 200;
+
+  // release the object
+  if (mAudioRecord != NULL) {
+    mAudioRecord->stop();
+    delete mAudioRecord;
+    mAudioRecord = NULL;
+  }
+
+  unsigned int frameCount =
+    minRecBufSize / (N_REC_CHANNELS * GetPCMSampleSize(N_AUDIO_FORMAT));
+  int channelMask = N_REC_CHANNELS == 1 ?
+                    AUDIO_CHANNEL_IN_MONO : AUDIO_CHANNEL_IN_STEREO;
+
+  mAudioRecord = new AudioRecord();
+  mAudioRecord->set(audioSource,     // inputSource
+                    sampleRate,      // sampleRate
+                    N_AUDIO_FORMAT,  // format
+                    channelMask,     // channelMask
+                    frameCount,      // frameCount
+                    0,               // flags
+                    NULL,            // cbf
+                    this,            // user
+                    0,               // notificationFrames
+                    false,           // threadCanCallJava
+                    0);              // sessionId
+
+  if (mAudioRecord->initCheck() != NO_ERROR) {
+    return -1;
+  }
+
+  return mBufferedRecSamples;
+}
+
+WebRtc_Word32 AudioDeviceGonk::InitRecording()
+{
+  CHECK_INITIALIZED();
+  ReentrantMonitorAutoEnter lock(mCritSect);
+  mAudioDeviceBuffer.InitRecording();
+
+  if (!mInitialized)
+  {
+    WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                 "  Not initialized");
+    return -1;
+  }
+
+  if (mRecording)
+  {
+    WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+                 "  Recording already started");
+    return -1;
+  }
+
+  if (!mRecordingDeviceIsSpecified)
+  {
+    WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                 "  Recording device is not specified");
+    return -1;
+  }
+
+  if (mRecIsInitialized)
+  {
+    WEBRTC_TRACE(kTraceInfo, kTraceAudioDevice, mId,
+                 "  Recording already initialized");
+    return 0;
+  }
+
+  // Initialize the microphone
+  if (InitMicrophone() == -1)
+  {
+    WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+                 "  InitMicrophone() failed");
+  }
+
+  int samplingFreq = 44100;
+  if (mSamplingFreqIn != 44)
+  {
+    samplingFreq = mSamplingFreqIn * 1000;
+  }
+
+  int retVal = -1;
+  int res = InitRecorderLocked(mRecAudioSource, samplingFreq);
+  if (res < 0)
+  {
+    WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                 "InitRecording failed (%d)", res);
+  }
+  else
+  {
+    // Set the audio device buffer sampling rate
+    mAudioDeviceBuffer.SetRecordingSampleRate(mSamplingFreqIn * 1000);
+
+    // the init rec function returns a fixed delay
+    mDelayRecording = res / mSamplingFreqIn;
+
+    mRecIsInitialized = true;
+    retVal = 0;
+  }
+
+  return retVal;
+}
+
+// ----------------------------------------------------------------------------
+//  PlayoutIsInitialized
+// ----------------------------------------------------------------------------
+
+bool AudioDeviceGonk::PlayoutIsInitialized() const
+{
+  CHECK_INITIALIZED_BOOL();
+  return mPlayIsInitialized;
+}
+
+// ----------------------------------------------------------------------------
+//  RecordingIsInitialized
+// ----------------------------------------------------------------------------
+
+bool AudioDeviceGonk::RecordingIsInitialized() const
+{
+  CHECK_INITIALIZED_BOOL();
+  return mRecIsInitialized;
+}
+
+// ----------------------------------------------------------------------------
+//  StartPlayout
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::StartPlayout()
+{
+  CHECK_INITIALIZED();
+  ReentrantMonitorAutoEnter lock(mCritSect);
+
+  if (!mPlayIsInitialized)
+  {
+    WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                 "  Playout not initialized");
+    return -1;
+  }
+
+  if (mPlaying)
+  {
+    WEBRTC_TRACE(kTraceInfo, kTraceAudioDevice, mId,
+                 "  Playout already started");
+    return 0;
+  }
+
+  mAudioTrack->start();
+
+  mPlayWarning = 0;
+  mPlayError = 0;
+
+  // Signal to playout thread that we want to start
+  mStartPlay = true;
+  mTimeEventPlay.Set(); // Release thread from waiting state
+  UnLock();
+  // Wait for thread to init
+  if (kEventSignaled != mPlayStartStopEvent.Wait(5000))
+  {
+      WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                   "  Timeout or error starting");
+  }
+  mPlayStartStopEvent.Reset();
+  Lock();
+
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  StopPlayout
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::StopPlayout()
+{
+  CHECK_INITIALIZED();
+  ReentrantMonitorAutoEnter lock(mCritSect);
+
+  if (!mPlayIsInitialized)
+  {
+    WEBRTC_TRACE(kTraceInfo, kTraceAudioDevice, mId,
+                 "  Playout is not initialized");
+    return 0;
+  }
+
+  mAudioTrack->stop();
+
+  mPlayIsInitialized = false;
+  mPlaying = false;
+  mPlayWarning = 0;
+  mPlayError = 0;
+
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  Playing
+// ----------------------------------------------------------------------------
+
+bool AudioDeviceGonk::Playing() const
+{
+  CHECK_INITIALIZED_BOOL();
+
+  ReentrantMonitorAutoEnter lock(mCritSect);
+  return mPlaying;
+}
+
+// ----------------------------------------------------------------------------
+//  StartRecording
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::StartRecording()
+{
+  CHECK_INITIALIZED();
+
+  ReentrantMonitorAutoEnter lock(mCritSect);
+
+  if (!mRecIsInitialized)
+  {
+    WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                 "  Recording not initialized");
+    return -1;
+  }
+
+  if (mRecording)
+  {
+    WEBRTC_TRACE(kTraceInfo, kTraceAudioDevice, mId,
+                 "  Recording already started");
+    return 0;
+  }
+
+  mAudioRecord->start();
+
+  mRecWarning = 0;
+  mRecError = 0;
+
+  // Signal to recording thread that we want to start
+  mStartRec = true;
+  mTimeEventRec.Set(); // Release thread from waiting state
+  UnLock();
+  // Wait for thread to init
+  if (kEventSignaled != mRecStartStopEvent.Wait(5000))
+  {
+    WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                 "  Timeout or error starting");
+  }
+  mRecStartStopEvent.Reset();
+  Lock();
+
+  return 0;
+}
+// ----------------------------------------------------------------------------
+//  StopRecording
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::StopRecording()
+{
+  CHECK_INITIALIZED();
+  ReentrantMonitorAutoEnter lock(mCritSect);
+
+  if (!mRecIsInitialized)
+  {
+    WEBRTC_TRACE(kTraceInfo, kTraceAudioDevice, mId,
+                 "  Recording is not initialized");
+    return 0;
+  }
+
+  // make sure we don't start recording (it's asynchronous),
+  // assuming that we are under lock
+  mStartRec = false;
+
+  mAudioRecord->stop();
+
+  mRecIsInitialized = false;
+  mRecording = false;
+  mRecWarning = 0;
+  mRecError = 0;
+
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  Recording
+// ----------------------------------------------------------------------------
+
+bool AudioDeviceGonk::Recording() const
+{
+  CHECK_INITIALIZED_BOOL();
+  ReentrantMonitorAutoEnter lock(mCritSect);
+  return mRecording;
+}
+
+// ----------------------------------------------------------------------------
+//  RegisterEventObserver
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::RegisterEventObserver(AudioDeviceObserver* eventCallback)
+{
+  ReentrantMonitorAutoEnter lock(mCritSectEventCb);
+  mPtrCbAudioDeviceObserver = eventCallback;
+
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  RegisterAudioCallback
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::RegisterAudioCallback(AudioTransport* audioCallback)
+{
+  ReentrantMonitorAutoEnter lock(mCritSectAudioCb);
+  mAudioDeviceBuffer.RegisterAudioCallback(audioCallback);
+
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  StartRawInputFileRecording
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::StartRawInputFileRecording(
+  const char pcmFileNameUTF8[kAdmMaxFileNameSize])
+{
+  CHECK_INITIALIZED();
+
+  if (NULL == pcmFileNameUTF8)
+  {
+    return -1;
+  }
+
+  return mAudioDeviceBuffer.StartInputFileRecording(pcmFileNameUTF8);
+}
+
+// ----------------------------------------------------------------------------
+//  StopRawInputFileRecording
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::StopRawInputFileRecording()
+{
+  CHECK_INITIALIZED();
+
+  return mAudioDeviceBuffer.StopInputFileRecording();
+}
+
+// ----------------------------------------------------------------------------
+//  StartRawOutputFileRecording
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::StartRawOutputFileRecording(
+    const char pcmFileNameUTF8[kAdmMaxFileNameSize])
+{
+  CHECK_INITIALIZED();
+
+  if (NULL == pcmFileNameUTF8)
+  {
+    return -1;
+  }
+
+  return mAudioDeviceBuffer.StartOutputFileRecording(pcmFileNameUTF8);
+}
+
+// ----------------------------------------------------------------------------
+//  StopRawOutputFileRecording
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::StopRawOutputFileRecording()
+{
+  CHECK_INITIALIZED();
+
+  return mAudioDeviceBuffer.StopOutputFileRecording();
+}
+
+// ----------------------------------------------------------------------------
+//  SetPlayoutBuffer
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::SetPlayoutBuffer(const BufferType type, WebRtc_UWord16 sizeMS)
+{
+  CHECK_INITIALIZED();
+  WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+               "  API call not supported on this platform: %s", __FUNCTION__);
+  return -1;
+}
+
+// ----------------------------------------------------------------------------
+//  PlayoutBuffer
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::PlayoutBuffer(BufferType* type, WebRtc_UWord16* sizeMS) const
+{
+  CHECK_INITIALIZED();
+  ReentrantMonitorAutoEnter lock(mCritSect);
+
+  BufferType bufType;
+  WebRtc_UWord16 size(0);
+
+  *type = AudioDeviceModule::kAdaptiveBufferSize;
+  *sizeMS = mDelayPlayout; // Set to current playout delay
+
+  WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId, "output: type=%u, sizeMS=%u", *type, *sizeMS);
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  PlayoutDelay
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::PlayoutDelay(WebRtc_UWord16* delayMS) const
+{
+  WEBRTC_TRACE(kTraceStream, kTraceAudioDevice, mId, "%s", __FUNCTION__);
+  CHECK_INITIALIZED();
+  ReentrantMonitorAutoEnter lock(mCritSect);
+
+  *delayMS = mDelayPlayout;
+
+  WEBRTC_TRACE(kTraceStream, kTraceAudioDevice, mId, "output: delayMS=%u", *delayMS);
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  RecordingDelay
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::RecordingDelay(WebRtc_UWord16* delayMS) const
+{
+  WEBRTC_TRACE(kTraceStream, kTraceAudioDevice, mId, "%s", __FUNCTION__);
+  CHECK_INITIALIZED();
+  ReentrantMonitorAutoEnter lock(mCritSect);
+
+  *delayMS = mDelayRecording;
+
+  WEBRTC_TRACE(kTraceStream, kTraceAudioDevice, mId, "output: delayMS=%u", *delayMS);
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  CPULoad
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::CPULoad(WebRtc_UWord16* load) const
+{
+  CHECK_INITIALIZED();
+  WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+               "  API call not supported on this platform: %s", __FUNCTION__);
+  return -1;
+}
+
+// ----------------------------------------------------------------------------
+//  SetRecordingSampleRate
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::SetRecordingSampleRate(const WebRtc_UWord32 samplesPerSec)
+{
+  CHECK_INITIALIZED();
+
+  if (samplesPerSec > 48000 || samplesPerSec < 8000)
+  {
+    WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                 "  Invalid sample rate");
+    return -1;
+  }
+
+  // set the recording sample rate to use
+  mSamplingFreqIn = samplesPerSec / 1000;
+
+  // Update the AudioDeviceBuffer
+  mAudioDeviceBuffer.SetRecordingSampleRate(samplesPerSec);
+
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  RecordingSampleRate
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::RecordingSampleRate(WebRtc_UWord32* samplesPerSec) const
+{
+  CHECK_INITIALIZED();
+
+  WebRtc_Word32 sampleRate = mAudioDeviceBuffer.RecordingSampleRate();
+
+  if (sampleRate == -1)
+  {
+      WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId, "failed to retrieve the sample rate");
+      return -1;
+  }
+
+  *samplesPerSec = sampleRate;
+
+  WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId, "output: samplesPerSec=%u", *samplesPerSec);
+  return (0);
+}
+
+// ----------------------------------------------------------------------------
+//  SetPlayoutSampleRate
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::SetPlayoutSampleRate(const WebRtc_UWord32 samplesPerSec)
+{
+  CHECK_INITIALIZED();
+
+  if (samplesPerSec > 48000 || samplesPerSec < 8000)
+  {
+    WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                 "  Invalid sample rate");
+    return -1;
+  }
+
+  // set the playout sample rate to use
+  mSamplingFreqOut = samplesPerSec / 1000;
+
+  // Update the AudioDeviceBuffer
+  mAudioDeviceBuffer.SetPlayoutSampleRate(samplesPerSec);
+
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  PlayoutSampleRate
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::PlayoutSampleRate(WebRtc_UWord32* samplesPerSec) const
+{
+  CHECK_INITIALIZED();
+
+  WebRtc_Word32 sampleRate = mAudioDeviceBuffer.PlayoutSampleRate();
+
+  if (sampleRate == -1)
+  {
+    WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId, "failed to retrieve the sample rate");
+    return -1;
+  }
+
+  *samplesPerSec = sampleRate;
+
+  WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId, "output: samplesPerSec=%u", *samplesPerSec);
+  return (0);
+}
+
+// ----------------------------------------------------------------------------
+//  ResetAudioDevice
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::ResetAudioDevice()
+{
+    CHECK_INITIALIZED();
+    WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+        "Reset audio device not supported on this platform");
+    return -1;
+}
+
+// ----------------------------------------------------------------------------
+//  SetLoudspeakerStatus
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::SetLoudspeakerStatus(bool enable)
+{
+  CHECK_INITIALIZED();
+
+  status_t err = AudioSystem::setForceUse((audio_policy_force_use_t)0, (audio_policy_forced_cfg_t)enable);
+  if (err != OK) {
+    return -1;
+  }
+
+  mLoudSpeakerOn = enable;
+  return 0;
+}
+
+// ----------------------------------------------------------------------------
+//  GetLoudspeakerStatus
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::GetLoudspeakerStatus(bool* enabled) const
+{
+  CHECK_INITIALIZED();
+  *enabled = mLoudSpeakerOn;
+  return 0;
+}
+
+int32_t AudioDeviceGonk::EnableBuiltInAEC(bool enable)
+{
+  CHECK_INITIALIZED();
+  WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+      "Windows AEC not supported on this platform");
+  return -1;
+}
+
+bool AudioDeviceGonk::BuiltInAECIsEnabled() const
+{
+  CHECK_INITIALIZED_BOOL();
+  WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+      "Windows AEC not supported on this platform");
+  return false;
+}
+
+// ============================================================================
+//                                 Private Methods
+// ============================================================================
+
+// ----------------------------------------------------------------------------
+//  InitSampleRate
+//
+//  checks supported sample rates for playback
+//  and recording and initializes the rates to be used
+//  Also stores the max playout volume returned from InitPlayout
+// ----------------------------------------------------------------------------
+
+WebRtc_Word32 AudioDeviceGonk::InitSampleRate()
+{
+  ReentrantMonitorAutoEnter lock(mCritSect);
+  int samplingFreq = 48000;
+  int res = 0;
+
+  if (mSamplingFreqIn > 0)
+  {
+    // read the configured sampling rate
+    samplingFreq = 44100;
+    if (mSamplingFreqIn != 44)
+    {
+        samplingFreq = mSamplingFreqIn * 1000;
+    }
+    WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId,
+                 "  Trying configured recording sampling rate %d",
+                 samplingFreq);
+  }
+
+  res = InitRecorderLocked(mRecAudioSource, samplingFreq);
+  // According to Android SDK, 44100 is guaranteed to work on all devices,
+  // when error occurs here, default to 44100
+  if (res < 0)
+  {
+    if (samplingFreq == 48000)
+    {
+      res = InitRecorderLocked(mRecAudioSource, 44100);
+    }
+    if (res < 0)
+    {
+      WEBRTC_TRACE(kTraceError,
+                   kTraceAudioDevice, mId,
+                   "%s: InitRecording failed (%d)", __FUNCTION__,
+                   res);
+    }
+    return -1;
+  }
+
+  // set the recording sample rate to use
+  mSamplingFreqIn = samplingFreq / 1000;
+
+  WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId,
+               "Recording sample rate set to (%d)", mSamplingFreqIn);
+
+  mAudioRecord->stop();
+
+  samplingFreq = 48000;
+  if (mSamplingFreqOut > 0)
+  {
+    // read the configured sampling rate
+    samplingFreq = 44100;
+    if (mSamplingFreqOut != 44)
+    {
+      samplingFreq = mSamplingFreqOut * 1000;
+    }
+    WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId,
+                 "  Trying configured playback sampling rate %d",
+                 samplingFreq);
+  }
+  else
+  {
+    // set the preferred sampling frequency
+    if (samplingFreq == 8000)
+    {
+      // try 16000
+      samplingFreq = 16000;
+    }
+  }
+
+  // Since Android HAL does not provide any reliable way to query which
+  // samplingFreqs it supports. We have to try it until one succeeds.
+  bool keepTrying = true;
+  while (keepTrying)
+  {
+    res = InitPlaybackLocked(samplingFreq);
+    if (res < 0)
+    {
+      switch (samplingFreq)
+      {
+        case 48000:
+          samplingFreq = 44100;
+          break;
+        case 44100:
+          samplingFreq = 16000;
+          break;
+        case 16000:
+          samplingFreq = 8000;
+          break;
+        default: // error
+          WEBRTC_TRACE(kTraceError,
+                       kTraceAudioDevice, mId,
+                       "InitSampleRate failed (%d)", res);
+          return -1;
+      }
+    }
+    else
+    {
+      keepTrying = false;
+    }
+  }
+
+  // Store max playout volume
+  mMaxSpeakerVolume = static_cast<WebRtc_UWord32> (res);
+  if (mMaxSpeakerVolume < 1)
+  {
+    WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice, mId,
+                 "  Did not get valid max speaker volume value (%d)",
+                 mMaxSpeakerVolume);
+  }
+
+  // set the playback sample rate to use
+  mSamplingFreqOut = samplingFreq / 1000;
+
+  WEBRTC_TRACE(kTraceStateInfo, kTraceAudioDevice, mId,
+               "Playback sample rate set to (%d)", mSamplingFreqOut);
+
+  mAudioTrack->stop();
+
+  return 0;
+}
+
+void AudioDeviceGonk::PlayThreadFunc() {
+  Lock();
+  if (!mPlayThreadIsInitialized)
+  {
+    // Do once when thread is started
+    mPlayThreadIsInitialized = true;
+  }
+
+  if (!mPlaying)
+  {
+    UnLock();
+    switch (mTimeEventPlay.Wait(1000))
+    {
+      case kEventSignaled:
+        WEBRTC_TRACE(kTraceDebug, kTraceAudioDevice,
+                     mId, "Playout thread event signal");
+        mTimeEventPlay.Reset();
+        break;
+      case kEventError:
+        WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice,
+                     mId, "Playout thread event error");
+        mThreadPlay->Dispatch(WrapRunnable(this, &AudioDeviceGonk::PlayThreadFunc), NS_DISPATCH_NORMAL);
+        return;
+      case kEventTimeout:
+        WEBRTC_TRACE(kTraceDebug, kTraceAudioDevice,
+                     mId, "Playout thread event timeout");
+        mThreadPlay->Dispatch(WrapRunnable(this, &AudioDeviceGonk::PlayThreadFunc), NS_DISPATCH_NORMAL);
+        return;
+    }
+    Lock();
+  }
+
+  if (mStartPlay)
+  {
+    WEBRTC_TRACE(kTraceInfo, kTraceAudioDevice, mId,
+                 "_startPlay true, performing initial actions");
+    mStartPlay = false;
+    mPlaying = true;
+    mPlayWarning = 0;
+    mPlayError = 0;
+    mPlayStartStopEvent.Set();
+    WEBRTC_TRACE(kTraceDebug, kTraceAudioDevice, mId,
+                 "Sent signal");
+  }
+
+  if (mPlaying)
+  {
+    const int sampleSize = GetPCMSampleSize(N_AUDIO_FORMAT);
+    WebRtc_Word8 playBuffer[PLAY_BUF_SIZE_IN_SAMPLES * sampleSize]; // Max 10 ms @ 48 kHz / 16 bit
+    WebRtc_UWord32 samplesToPlay = mSamplingFreqOut * 10;
+
+    UnLock();
+    // ask for new PCM data to be played out using the AudioDeviceBuffer
+    // ensure that this callback is executed without taking the
+    // audio-thread lock
+    WebRtc_UWord32 nSamples =
+      mAudioDeviceBuffer.RequestPlayoutData(samplesToPlay);
+    Lock();
+
+    // Check again since play may have stopped during unlocked period
+    if (!mPlaying)
+    {
+      UnLock();
+      mThreadPlay->Dispatch(WrapRunnable(this, &AudioDeviceGonk::PlayThreadFunc), NS_DISPATCH_NORMAL);
+      return;
+    }
+    UnLock();
+    nSamples = mAudioDeviceBuffer.GetPlayoutData(playBuffer);
+    Lock();
+    if (nSamples != samplesToPlay)
+    {
+      WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                   "  invalid number of output samples(%d)", nSamples);
+      mPlayWarning = 1;
+    }
+
+    // Copy data to our direct buffer
+    UnLock();
+    int written = mAudioTrack->write(playBuffer, nSamples * N_PLAY_CHANNELS *
+                                     sampleSize);
+    Lock();
+    if (written < 0)
+    {
+      WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                   "  playback failed with error(%d)", written);
+      mPlayError = written;
+    }
+
+    mBufferedPlaySamples += (written / (sampleSize * N_PLAY_CHANNELS));
+
+    uint32_t pos;
+    mAudioTrack->getPosition(&pos);
+    MOZ_ASSERT(pos >= mPlayPosition);
+    mBufferedPlaySamples -= (pos - mPlayPosition);
+    mPlayPosition = pos;
+
+    // we are not recording and have got a delay value from playback
+    mDelayPlayout = written / mSamplingFreqOut;
+  } // _playing
+
+  if (mShutdownPlayThread)
+  {
+    WEBRTC_TRACE(kTraceDebug, kTraceAudioDevice, mId,
+                 "ShutdownPlayThread");
+
+    mShutdownPlayThread = false;
+    mPlayStartStopEvent.Set(); // Signal to Terminate() that we are done
+    WEBRTC_TRACE(kTraceDebug, kTraceAudioDevice, mId,
+                 "Sent signal");
+  }
+
+  UnLock();
+  mThreadPlay->Dispatch(WrapRunnable(this, &AudioDeviceGonk::PlayThreadFunc), NS_DISPATCH_NORMAL);
+  return;
+}
+
+void AudioDeviceGonk::RecThreadFunc() {
+  Lock();
+  if (!mRecThreadIsInitialized)
+  {
+    mRecThreadIsInitialized = true;
+  }
+
+  // just sleep if rec has not started
+  if (!mRecording)
+  {
+    UnLock();
+    switch (mTimeEventRec.Wait(1000))
+    {
+      case kEventSignaled:
+        WEBRTC_TRACE(kTraceDebug, kTraceAudioDevice,
+                     mId, "Recording thread event signal");
+        mTimeEventRec.Reset();
+        break;
+      case kEventError:
+        WEBRTC_TRACE(kTraceWarning, kTraceAudioDevice,
+                     mId, "Recording thread event error");
+        mThreadRec->Dispatch(WrapRunnable(this, &AudioDeviceGonk::RecThreadFunc), NS_DISPATCH_NORMAL);
+        return;
+      case kEventTimeout:
+        WEBRTC_TRACE(kTraceDebug, kTraceAudioDevice,
+                     mId, "Recording thread event timeout");
+        mThreadRec->Dispatch(WrapRunnable(this, &AudioDeviceGonk::RecThreadFunc), NS_DISPATCH_NORMAL);
+        return;
+    }
+    Lock();
+  }
+
+  if (mStartRec)
+  {
+    WEBRTC_TRACE(kTraceInfo, kTraceAudioDevice, mId,
+                 "_startRec true, performing initial actions");
+    mStartRec = false;
+    mRecording = true;
+    mRecWarning = 0;
+    mRecError = 0;
+    mRecStartStopEvent.Set();
+  }
+
+  if (mRecording)
+  {
+    WebRtc_UWord32 samplesToRec = mSamplingFreqIn * 10;
+
+    int playDelayInSamples = mBufferedPlaySamples;
+    MOZ_ASSERT(playDelayInSamples >= 0);
+    mDelayPlayout = playDelayInSamples / mSamplingFreqOut;
+
+    // Copy data to our direct buffer
+    UnLock();
+    int sizeInBytes = GetPCMSampleSize(N_AUDIO_FORMAT) * samplesToRec;
+    int recorderBuffSize = mAudioRecord->frameCount() * mAudioRecord->frameSize();
+    int readSize = mAudioRecord->read(mRecBuffer, sizeInBytes > recorderBuffSize ? recorderBuffSize : sizeInBytes);
+    Lock();
+    if (readSize <= 0)
+    {
+      WEBRTC_TRACE(kTraceError, kTraceAudioDevice, mId,
+                   "read AudioRecord failed(%d)", readSize);
+      mRecError = readSize;
+    }
+
+    // store the recorded buffer (no action will be taken if the
+    // #recorded samples is not a full buffer)
+    mAudioDeviceBuffer.SetRecordedBuffer(mRecBuffer, samplesToRec);
+
+    // store vqe delay values
+    mAudioDeviceBuffer.SetVQEData(mDelayPlayout, mDelayRecording, 0);
+
+    // deliver recorded samples at specified sample rate, mic level
+    // etc. to the observer using callback
+    UnLock();
+    mAudioDeviceBuffer.DeliverRecordedData();
+    Lock();
+  } // _recording
+
+  if (mShutdownRecThread)
+  {
+    WEBRTC_TRACE(kTraceDebug, kTraceAudioDevice, mId,
+                 "Detaching rec thread from Java VM");
+
+    mShutdownRecThread = false;
+    mRecStartStopEvent.Set();
+  }
+
+  UnLock();
+  mThreadRec->Dispatch(WrapRunnable(this, &AudioDeviceGonk::RecThreadFunc), NS_DISPATCH_NORMAL);
+  return;
+}
+
+}  // namespace webrtc
diff --git a/content/media/webrtc/AudioDeviceGonk.h b/content/media/webrtc/AudioDeviceGonk.h
new file mode 100644
index 0000000..b2d8d73
--- /dev/null
+++ b/content/media/webrtc/AudioDeviceGonk.h
@@ -0,0 +1,317 @@
+/*
+ *  Copyright (c) 2012 The WebRTC project authors. All Rights Reserved.
+ *
+ *  Use of this source code is governed by a BSD-style license
+ *  that can be found in the LICENSE file in the root of the source
+ *  tree. An additional intellectual property rights grant can be found
+ *  in the file PATENTS.  All contributing project authors may
+ *  be found in the AUTHORS file in the root of the source tree.
+ */
+
+#ifndef WEBRTC_AUDIO_DEVICE_AUDIO_DEVICE_GONK_H
+#define WEBRTC_AUDIO_DEVICE_AUDIO_DEVICE_GONK_H
+
+#include "audio_device.h"
+#include "audio_device_buffer.h"
+#include "ReentrantMonitor.h"
+#include "nsAutoPtr.h"
+#include "nsIThread.h"
+
+#include "utils/RefBase.h"
+#include "media/AudioTrack.h"
+#include "media/AudioRecord.h"
+
+namespace mozilla
+{
+class ReentrantMonitor;
+}
+
+namespace webrtc
+{
+class EventWrapper;
+
+const uint32_t N_REC_SAMPLES_PER_SEC = 44000; // Default is 44.1 kHz
+const uint32_t N_PLAY_SAMPLES_PER_SEC = 44000; // Default is 44.1 kHz
+
+const uint32_t N_REC_CHANNELS = 1; // default is mono recording
+const uint32_t N_PLAY_CHANNELS = 1; // default is mono playout
+const uint32_t N_AUDIO_FORMAT = AUDIO_FORMAT_PCM_16_BIT;
+
+const uint32_t PLAY_BUF_SIZE_IN_SAMPLES = 480; // Handle max 10 ms @ 48 kHz
+const uint32_t REC_BUF_SIZE_IN_SAMPLES = 480;
+
+class AudioDeviceGeneric;
+class AudioDeviceUtility;
+class CriticalSectionWrapper;
+
+class AudioDeviceGonk : public AudioDeviceModule
+{
+public:
+  WebRtc_Word32 AttachAudioBuffer();
+
+  AudioDeviceGonk(const WebRtc_Word32 id, const AudioLayer audioLayer);
+  virtual ~AudioDeviceGonk();
+
+public: // RefCountedModule
+  virtual WebRtc_Word32 ChangeUniqueId(const WebRtc_Word32 id);
+  virtual WebRtc_Word32 TimeUntilNextProcess();
+  virtual WebRtc_Word32 Process();
+
+public:
+  // Factory methods (resource allocation/deallocation)
+  static AudioDeviceModule* Create(
+    const WebRtc_Word32 id,
+    const AudioLayer audioLayer = kPlatformDefaultAudio);
+
+  // Retrieve the currently utilized audio layer
+  virtual WebRtc_Word32 ActiveAudioLayer(AudioLayer* audioLayer) const;
+
+  // Error handling
+  virtual ErrorCode LastError() const;
+  virtual WebRtc_Word32 RegisterEventObserver(
+    AudioDeviceObserver* eventCallback);
+
+  // Full-duplex transportation of PCM audio
+  virtual WebRtc_Word32 RegisterAudioCallback(
+    AudioTransport* audioCallback);
+
+  // Main initializaton and termination
+  virtual WebRtc_Word32 Init();
+  virtual WebRtc_Word32 Terminate();
+  virtual bool Initialized() const;
+
+  // Device enumeration
+  virtual WebRtc_Word16 PlayoutDevices();
+  virtual WebRtc_Word16 RecordingDevices();
+  virtual WebRtc_Word32 PlayoutDeviceName(
+    WebRtc_UWord16 index,
+    char name[kAdmMaxDeviceNameSize],
+    char guid[kAdmMaxGuidSize]);
+  virtual WebRtc_Word32 RecordingDeviceName(
+    WebRtc_UWord16 index,
+    char name[kAdmMaxDeviceNameSize],
+    char guid[kAdmMaxGuidSize]);
+
+  // Device selection
+  virtual WebRtc_Word32 SetPlayoutDevice(WebRtc_UWord16 index);
+  virtual WebRtc_Word32 SetPlayoutDevice(WindowsDeviceType device);
+  virtual WebRtc_Word32 SetRecordingDevice(WebRtc_UWord16 index);
+  virtual WebRtc_Word32 SetRecordingDevice(WindowsDeviceType device);
+
+  // Audio transport initialization
+  virtual WebRtc_Word32 PlayoutIsAvailable(bool* available);
+  virtual WebRtc_Word32 InitPlayout();
+  virtual bool PlayoutIsInitialized() const;
+  virtual WebRtc_Word32 RecordingIsAvailable(bool* available);
+  virtual WebRtc_Word32 InitRecording();
+  virtual bool RecordingIsInitialized() const;
+
+  // Audio transport control
+  virtual WebRtc_Word32 StartPlayout();
+  virtual WebRtc_Word32 StopPlayout();
+  virtual bool Playing() const;
+  virtual WebRtc_Word32 StartRecording();
+  virtual WebRtc_Word32 StopRecording();
+  virtual bool Recording() const;
+
+  // Microphone Automatic Gain Control (AGC)
+  virtual WebRtc_Word32 SetAGC(bool enable);
+  virtual bool AGC() const;
+
+  // Volume control based on the Windows Wave API (Windows only)
+  virtual WebRtc_Word32 SetWaveOutVolume(WebRtc_UWord16 volumeLeft,
+                                         WebRtc_UWord16 volumeRight);
+  virtual WebRtc_Word32 WaveOutVolume(WebRtc_UWord16* volumeLeft,
+                                      WebRtc_UWord16* volumeRight) const;
+
+  // Audio mixer initialization
+  virtual WebRtc_Word32 SpeakerIsAvailable(bool* available);
+  virtual WebRtc_Word32 InitSpeaker();
+  virtual bool SpeakerIsInitialized() const;
+  virtual WebRtc_Word32 MicrophoneIsAvailable(bool* available);
+  virtual WebRtc_Word32 InitMicrophone();
+  virtual bool MicrophoneIsInitialized() const;
+
+  // Speaker volume controls
+  virtual WebRtc_Word32 SpeakerVolumeIsAvailable(bool* available);
+  virtual WebRtc_Word32 SetSpeakerVolume(WebRtc_UWord32 volume);
+  virtual WebRtc_Word32 SpeakerVolume(WebRtc_UWord32* volume) const;
+  virtual WebRtc_Word32 MaxSpeakerVolume(WebRtc_UWord32* maxVolume) const;
+  virtual WebRtc_Word32 MinSpeakerVolume(WebRtc_UWord32* minVolume) const;
+  virtual WebRtc_Word32 SpeakerVolumeStepSize(
+    WebRtc_UWord16* stepSize) const;
+
+  // Microphone volume controls
+  virtual WebRtc_Word32 MicrophoneVolumeIsAvailable(bool* available);
+  virtual WebRtc_Word32 SetMicrophoneVolume(WebRtc_UWord32 volume);
+  virtual WebRtc_Word32 MicrophoneVolume(WebRtc_UWord32* volume) const;
+  virtual WebRtc_Word32 MaxMicrophoneVolume(
+    WebRtc_UWord32* maxVolume) const;
+  virtual WebRtc_Word32 MinMicrophoneVolume(
+    WebRtc_UWord32* minVolume) const;
+  virtual WebRtc_Word32 MicrophoneVolumeStepSize(
+    WebRtc_UWord16* stepSize) const;
+
+  // Speaker mute control
+  virtual WebRtc_Word32 SpeakerMuteIsAvailable(bool* available);
+  virtual WebRtc_Word32 SetSpeakerMute(bool enable);
+  virtual WebRtc_Word32 SpeakerMute(bool* enabled) const;
+
+  // Microphone mute control
+  virtual WebRtc_Word32 MicrophoneMuteIsAvailable(bool* available);
+  virtual WebRtc_Word32 SetMicrophoneMute(bool enable);
+  virtual WebRtc_Word32 MicrophoneMute(bool* enabled) const;
+
+  // Microphone boost control
+  virtual WebRtc_Word32 MicrophoneBoostIsAvailable(bool* available);
+  virtual WebRtc_Word32 SetMicrophoneBoost(bool enable);
+  virtual WebRtc_Word32 MicrophoneBoost(bool* enabled) const;
+
+  // Stereo support
+  virtual WebRtc_Word32 StereoPlayoutIsAvailable(bool* available) const;
+  virtual WebRtc_Word32 SetStereoPlayout(bool enable);
+  virtual WebRtc_Word32 StereoPlayout(bool* enabled) const;
+  virtual WebRtc_Word32 StereoRecordingIsAvailable(bool* available) const;
+  virtual WebRtc_Word32 SetStereoRecording(bool enable);
+  virtual WebRtc_Word32 StereoRecording(bool* enabled) const;
+  virtual WebRtc_Word32 SetRecordingChannel(const ChannelType channel);
+  virtual WebRtc_Word32 RecordingChannel(ChannelType* channel) const;
+
+  // Delay information and control
+  virtual WebRtc_Word32 SetPlayoutBuffer(const BufferType type,
+                                         WebRtc_UWord16 sizeMS = 0);
+  virtual WebRtc_Word32 PlayoutBuffer(BufferType* type,
+                                      WebRtc_UWord16* sizeMS) const;
+  virtual WebRtc_Word32 PlayoutDelay(WebRtc_UWord16* delayMS) const;
+  virtual WebRtc_Word32 RecordingDelay(WebRtc_UWord16* delayMS) const;
+
+  // CPU load
+  virtual WebRtc_Word32 CPULoad(WebRtc_UWord16* load) const;
+
+  // Recording of raw PCM data
+  virtual WebRtc_Word32 StartRawOutputFileRecording(
+    const char pcmFileNameUTF8[kAdmMaxFileNameSize]);
+  virtual WebRtc_Word32 StopRawOutputFileRecording();
+  virtual WebRtc_Word32 StartRawInputFileRecording(
+    const char pcmFileNameUTF8[kAdmMaxFileNameSize]);
+  virtual WebRtc_Word32 StopRawInputFileRecording();
+
+  // Native sample rate controls (samples/sec)
+  virtual WebRtc_Word32 SetRecordingSampleRate(
+    const WebRtc_UWord32 samplesPerSec);
+  virtual WebRtc_Word32 RecordingSampleRate(
+    WebRtc_UWord32* samplesPerSec) const;
+  virtual WebRtc_Word32 SetPlayoutSampleRate(
+    const WebRtc_UWord32 samplesPerSec);
+  virtual WebRtc_Word32 PlayoutSampleRate(
+    WebRtc_UWord32* samplesPerSec) const;
+
+  // Mobile device specific functions
+  virtual WebRtc_Word32 ResetAudioDevice();
+  virtual WebRtc_Word32 SetLoudspeakerStatus(bool enable);
+  virtual WebRtc_Word32 GetLoudspeakerStatus(bool* enabled) const;
+
+  virtual int32_t EnableBuiltInAEC(bool enable);
+  virtual bool BuiltInAECIsEnabled() const;
+
+public:
+  WebRtc_Word32 Id() {return mId;}
+
+private:
+  int InitPlaybackLocked(int sampleRate);
+  int InitRecorderLocked(int audioSource, int sampleRate);
+  WebRtc_Word32 InitSampleRate();
+  void PlayThreadFunc();
+  void RecThreadFunc();
+
+  // Lock
+  void Lock()
+  {
+    mCritSect.Enter();
+  };
+
+  void UnLock()
+  {
+    mCritSect.Exit();
+  };
+private:
+  mutable mozilla::ReentrantMonitor mCritSect;
+  mozilla::ReentrantMonitor mCritSectEventCb;
+  mozilla::ReentrantMonitor mCritSectAudioCb;
+
+  AudioDeviceObserver* mPtrCbAudioDeviceObserver;
+
+  AudioDeviceBuffer mAudioDeviceBuffer;
+
+  WebRtc_Word32 mId;
+  WebRtc_UWord32 mLastProcessTime;
+  bool mInitialized;
+  mutable ErrorCode mLastError;
+
+  // Events
+  EventWrapper& mTimeEventRec;
+  EventWrapper& mTimeEventPlay;
+  EventWrapper& mRecStartStopEvent;
+  EventWrapper& mPlayStartStopEvent;
+
+  // Threads
+  nsRefPtr<nsIThread> mThreadPlay;
+  nsRefPtr<nsIThread> mThreadRec;
+  bool mPlayThreadIsInitialized;
+  bool mRecThreadIsInitialized;
+  bool mShutdownPlayThread;
+  bool mShutdownRecThread;
+
+  // Rec buffer
+  int8_t mRecBuffer[2 * REC_BUF_SIZE_IN_SAMPLES];
+
+  // States
+  bool mRecordingDeviceIsSpecified;
+  bool mPlayoutDeviceIsSpecified;
+  bool mRecording;
+  bool mPlaying;
+  bool mRecIsInitialized;
+  bool mPlayIsInitialized;
+  bool mMicIsInitialized;
+  bool mSpeakerIsInitialized;
+
+  // Signal flags to threads
+  bool mStartRec;
+  bool mStopRec;
+  bool mStartPlay;
+  bool mStopPlay;
+
+  // Warnings and errors
+  WebRtc_UWord16 mPlayWarning;
+  WebRtc_UWord16 mPlayError;
+  WebRtc_UWord16 mRecWarning;
+  WebRtc_UWord16 mRecError;
+
+  // Delay
+  WebRtc_UWord16 mDelayPlayout;
+  WebRtc_UWord16 mDelayRecording;
+
+  // AGC state
+  bool mAGC;
+
+  // Stored device properties
+  WebRtc_UWord16 mSamplingFreqIn; // Sampling frequency for Mic
+  WebRtc_UWord16 mSamplingFreqOut; // Sampling frequency for Speaker
+  WebRtc_UWord32 mMaxSpeakerVolume; // The maximum speaker volume value
+  bool mLoudSpeakerOn;
+  // Stores the desired audio source to use, set in SetRecordingDevice
+  int mRecAudioSource;
+
+  // porting from Android JAVA layer
+  int mBufferedPlaySamples;
+  int mBufferedRecSamples;
+  int mPlayPosition;
+  android::AudioTrack* mAudioTrack;
+  android::AudioRecord* mAudioRecord;
+
+  android::sp<android::IAudioFlinger> mAudioFlinger;
+};
+
+}  // namespace webrtc
+
+#endif  // WEBRTC_AUDIO_DEVICE_AUDIO_DEVICE_GONK_H
-- 
1.7.12.4 (Apple Git-37)

